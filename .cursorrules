# Cursor Rules for Next.js 14 + Tailwind CSS + Shadcn UI + Vercel + Supabase

## Project Overview
This project uses:
- **Next.js 14** (App Router) - Latest stable version (14.2.x)
- **TypeScript** - Strict mode enabled
- **Tailwind CSS** - With CSS variables for theming
- **Shadcn UI** - Component library with Radix UI primitives
- **Vercel** - Deployment platform
- **Supabase** - Backend as a Service (PostgreSQL, Auth, Storage, Realtime)

## Code Style & Best Practices

### General Principles
- Use TypeScript for all new files
- Follow strict TypeScript configuration
- Use functional components with hooks
- Prefer async/await over promises
- Use meaningful variable and function names
- Write self-documenting code with clear intent

### File Naming Conventions
- Components: PascalCase (e.g., `UserProfile.tsx`)
- Utilities: camelCase (e.g., `formatDate.ts`)
- Hooks: camelCase with `use` prefix (e.g., `useAuth.ts`)
- Pages/Routes: lowercase with hyphens (e.g., `user-profile/page.tsx`)
- Types/Interfaces: PascalCase (e.g., `User.ts` or `types.ts`)

## Next.js 14 App Router Patterns

### Server Components (Default)
- Use Server Components by default for better performance
- Server Components can directly access databases and APIs
- No `'use client'` directive needed for Server Components
- Use Server Components for:
  - Data fetching
  - Accessing backend resources
  - Keeping sensitive information on the server
  - Large dependencies that reduce client bundle size

### Client Components
- Add `'use client'` directive at the top of the file
- Use Client Components for:
  - Interactivity (onClick, onChange, etc.)
  - Browser APIs (localStorage, window, etc.)
  - React hooks (useState, useEffect, useContext, etc.)
  - Event listeners
  - Custom hooks that use browser APIs

### Route Structure
```
app/
  layout.tsx          # Root layout
  page.tsx            # Home page
  (routes)/           # Route groups
    dashboard/
      page.tsx
      layout.tsx
    profile/
      page.tsx
```

### Data Fetching
- Use `async/await` in Server Components
- Use `fetch` with Next.js caching options
- For Supabase: Use server-side client in Server Components
- Example:
```typescript
// Server Component
async function getData() {
  const supabase = createServerClient()
  const { data } = await supabase.from('table').select()
  return data
}
```

### Metadata & SEO
- Export `metadata` object or `generateMetadata` function
- Use dynamic metadata for dynamic routes
- Example:
```typescript
export const metadata: Metadata = {
  title: 'Page Title',
  description: 'Page description',
}
```

### Loading & Error States
- Create `loading.tsx` for loading states
- Create `error.tsx` for error boundaries
- Create `not-found.tsx` for 404 pages

### Route Handlers (API Routes)
- Place in `app/api/[route]/route.ts`
- Export named functions: GET, POST, PUT, DELETE, etc.
- Use `NextResponse` for responses
- Example:
```typescript
export async function GET(request: Request) {
  return NextResponse.json({ data: 'response' })
}
```

## Tailwind CSS Guidelines

### Class Organization
- Order classes logically: layout → spacing → typography → colors → effects
- Use Tailwind's responsive prefixes: `sm:`, `md:`, `lg:`, `xl:`, `2xl:`
- Use dark mode classes: `dark:bg-slate-900`
- Prefer utility classes over custom CSS

### Custom Colors
- Use CSS variables defined in `globals.css` for theme colors
- Access via: `bg-background`, `text-foreground`, `border-border`
- Use semantic color names: `primary`, `secondary`, `destructive`, etc.

### Responsive Design
- Mobile-first approach
- Breakpoints: sm (640px), md (768px), lg (1024px), xl (1280px), 2xl (1536px)
- Example: `flex flex-col md:flex-row`

### Spacing & Sizing
- Use consistent spacing scale (0, 1, 2, 4, 6, 8, 12, 16, 24, 32, etc.)
- Use `gap-*` for flex/grid spacing
- Use `p-*` and `m-*` for padding and margin

### Performance
- Avoid arbitrary values when possible
- Use `@apply` sparingly (only in CSS files)
- Purge unused styles automatically (handled by Tailwind)

## Shadcn UI Patterns

### Component Usage
- Components are in `@/components/ui`
- Import from `@/components/ui/[component]`
- All components are customizable and copy-paste friendly
- Example:
```typescript
import { Button } from "@/components/ui/button"
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card"
```

### Component Composition
- Use `cn()` utility from `@/lib/utils` for conditional classes
- Combine with `tailwind-merge` for class merging
- Example:
```typescript
import { cn } from "@/lib/utils"
<div className={cn("base-classes", condition && "conditional-classes")} />
```

### Form Components
- Use `react-hook-form` with `@hookform/resolvers` and `zod` for validation
- Use Shadcn form components: `Form`, `FormField`, `FormItem`, etc.
- Example pattern:
```typescript
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
```

### Accessibility
- All Shadcn components are built with Radix UI (accessible by default)
- Maintain keyboard navigation
- Ensure proper ARIA labels
- Test with screen readers

## Supabase Integration

### Client Creation
- Server Components: Use `createServerClient()` from Supabase helpers
- Client Components: Use `createBrowserClient()` or `createClient()`
- Store Supabase client creation in `@/lib/supabase/server.ts` and `@/lib/supabase/client.ts`

### Authentication
- Use Supabase Auth helpers for Next.js
- Server-side: `getUser()` or `getSession()`
- Client-side: `useUser()` hook or `supabase.auth.getUser()`
- Protect routes with middleware or Server Component checks

### Database Queries
- Use TypeScript types generated from Supabase schema
- Prefer `.select()` with specific columns
- Use RPC for complex queries
- Handle errors gracefully
- Example:
```typescript
const { data, error } = await supabase
  .from('users')
  .select('id, name, email')
  .eq('status', 'active')
  .single()

if (error) {
  // Handle error
}
```

### Realtime Subscriptions
- Use in Client Components only
- Clean up subscriptions in useEffect cleanup
- Example:
```typescript
useEffect(() => {
  const channel = supabase
    .channel('table-changes')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'table' }, (payload) => {
      // Handle change
    })
    .subscribe()

  return () => {
    supabase.removeChannel(channel)
  }
}, [])
```

### Row Level Security (RLS)
- Always enable RLS on Supabase tables
- Write policies for authenticated users
- Test policies in development

### Storage
- Use `supabase.storage.from('bucket').upload()` for uploads
- Generate signed URLs for private files
- Use public URLs for public files

## Vercel Deployment

### Environment Variables
- Use `.env.local` for local development
- Set environment variables in Vercel dashboard
- Never commit `.env.local` to git
- Prefix Supabase variables: `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- Server-only variables: `SUPABASE_SERVICE_ROLE_KEY` (no NEXT_PUBLIC prefix)

### Build Configuration
- Next.js automatically optimizes for Vercel
- Use `next/image` for images (automatic optimization)
- Use `next/font` for fonts (automatic optimization)
- Enable Edge Runtime when appropriate: `export const runtime = 'edge'`

### Performance
- Use Server Components to reduce bundle size
- Implement proper caching strategies
- Use `next/dynamic` for code splitting
- Optimize images with `next/image`

### Analytics & Monitoring
- Use Vercel Analytics for performance monitoring
- Use Vercel Speed Insights for Core Web Vitals
- Monitor Edge Function execution times

## TypeScript Patterns

### Type Definitions
- Define types in `types/` directory or co-located with components
- Use interfaces for object shapes
- Use types for unions, intersections, and computed types
- Export types for reuse

### Type Safety
- Avoid `any` - use `unknown` if type is truly unknown
- Use type assertions sparingly
- Leverage TypeScript's type inference
- Use `satisfies` operator when appropriate (TypeScript 4.9+)

### Supabase Types
- Generate types from Supabase schema: `supabase gen types typescript`
- Store in `types/supabase.ts`
- Use generated types for database queries

## File Structure

```
app/                    # Next.js App Router
  (routes)/             # Route groups
    [id]/               # Dynamic routes
      page.tsx
      layout.tsx
      loading.tsx
      error.tsx
  api/                  # API routes
    [route]/
      route.ts
  globals.css           # Global styles
  layout.tsx            # Root layout
  page.tsx              # Home page

components/
  ui/                   # Shadcn UI components
  [feature]/            # Feature-specific components

lib/
  supabase/
    server.ts           # Server Supabase client
    client.ts           # Client Supabase client
  utils.ts              # Utility functions

types/
  supabase.ts           # Generated Supabase types
  [feature].ts          # Feature-specific types

hooks/                  # Custom React hooks
```

## Common Patterns

### Form Handling
```typescript
'use client'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import * as z from 'zod'

const formSchema = z.object({
  email: z.string().email(),
})

export function MyForm() {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
  })
  
  // Form implementation
}
```

### Server Action Pattern
```typescript
'use server'
import { createServerClient } from '@/lib/supabase/server'

export async function myAction(formData: FormData) {
  const supabase = createServerClient()
  // Server-side logic
}
```

### Error Handling
- Always handle errors in try-catch blocks
- Provide user-friendly error messages
- Log errors appropriately
- Use error boundaries for React errors

### Loading States
- Use Suspense boundaries for loading states
- Show skeleton loaders for better UX
- Use `loading.tsx` files for route-level loading

## Code Quality

### Imports
- Group imports: external → internal → types
- Use absolute imports with `@/` alias
- Remove unused imports

### Comments
- Write self-documenting code
- Add comments for complex logic only
- Use JSDoc for function documentation

### Testing Considerations
- Write testable code (pure functions when possible)
- Keep components focused and single-purpose
- Mock Supabase clients in tests

## Security Best Practices

- Never expose service role keys to the client
- Validate all user inputs
- Use Supabase RLS for database security
- Sanitize user-generated content
- Use HTTPS in production (automatic on Vercel)
- Implement rate limiting for API routes
- Use environment variables for secrets

## Performance Optimization

- Use Server Components by default
- Implement proper caching (Next.js and Supabase)
- Optimize images with `next/image`
- Use `next/dynamic` for code splitting
- Minimize client-side JavaScript
- Use Edge Runtime when appropriate
- Implement proper database indexing in Supabase

## When Making Changes

1. **New Features**: Create feature branch, implement, test, then merge
2. **Components**: Add to appropriate directory, use Shadcn patterns
3. **API Routes**: Place in `app/api/`, use proper HTTP methods
4. **Database Changes**: Update Supabase schema, regenerate types
5. **Styling**: Use Tailwind utilities, maintain design system consistency
6. **Types**: Keep TypeScript types up to date with Supabase schema

## Additional Notes

- Always test locally before deploying
- Check Vercel build logs for issues
- Monitor Supabase dashboard for query performance
- Keep dependencies up to date
- Follow Next.js 14 migration guide if upgrading
- Use React 19 features when appropriate (the project uses React 19)
